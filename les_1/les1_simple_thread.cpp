
#include "app.h"
#include "thread_guard.h"
#include <iostream>

/*
 * Следующий заголовок нужно подключать, если вы хотите использовать потоки STL
 */
#include <thread>
 
using namespace Tools;

class Lesson_1 : public Application {
public:
	void start() const;
	

}; // class Lesson_1

//----------------------------------------------------------------
/*
 * В С++ используют callable объекты, которые выполняют работу
 * в потоке. До появления лямбда выражений обычно использовали функциональные
 * объекты (функторы). Если поток выполняет небольшую работу, то удобно использовать
 * лямбда выражения, так как код получается более компактным.
 *
 * Следующий класс реализует простую фоновую задачу и построен как функтор.
 */
class background_task {
public:
	void operator()() const
	{
		/* 
		 * Сюда вы пишите тело потока. Для простоты мы выведем строку на экран.
		 * Обратите внимание, что мы перехватываем исключения в потоке - этот
		 * момент будет объяснен позже, - поэтому все потоки обычно имеют 
		 * try...catch конструкцию в своем теле.
		 */
		try {
			std::cout << "Hello, World! I'm background task that launched from a functor" << std::endl;
		}
		catch (...) {
			std::cout << __FILE__ << " (" << __LINE__ << ")" << ":" << __FUNCTION__
			          << std::endl;
		}
	}
	
 }; // class background_task

/* 
 * Вы можете использовать простые функции, которые будут запущены в отдельном потоке.
 * 
 * Следующую функцию мы запустим в отдельном потоке. 
 */
 
void background_task_as_function() {
	try {
			std::cout << "Hello, World! I'm background task that launched from a simple function" << std::endl;
	}
	catch (...) {
		std::cout << __FILE__ << " (" << __LINE__ << ")" << ":" << __FUNCTION__
				  << std::endl;
	}
}
 
void Lesson_1::start() const {
	std::cout << "Lesson 1\nSimple threads\n" << std::endl;
/* !========
 * Чтобы создать поток из функтора:
 * 
 * 1. Объявите объект как обычно
 */
	background_task 	bt;

/* 2. Используйте низкоуровневый интерфейс потоков STL, чтобы запустить фоновую задачу */
	std::thread my_thread(bt);

/* 3. Выберите, что должен сделать текущий поток: дождаться того, что был запущен, или отсоединиться от него 
 * 
 * В этом примере мы просто отсоединяемся от потока, который был создан
 */
	my_thread.detach();
/* На этом процесс создания отдельного потока заканчивается. */

/* !========
 * Чтобы создать поток из функции:
 *
 * 1. Воспользуйтесь одной из следующих конструкций
 */
	std::thread my_thread_1(background_task_as_function);
	my_thread_1.detach();
		
	// Можно воспользоваться универсальным синтаксисом инициализации, введенным в С++11.
	std::thread my_thread_2 {background_task_as_function};
	my_thread_2.detach();
	
/* !========
 * Чтобы создать поток из лямбда функции, ее необходимо передать каким-либо способом объекту
 * std::thread
 */	
	std::thread my_thread_3([]() {
		try {
			std::cout << "Hello, World! I'm background task that launched from a lambda function" << std::endl;
		}
		catch (...) {
			std::cout << __FILE__ << " (" << __LINE__ << ")" << ":" << __FUNCTION__
					  << std::endl;
		}
	});
	my_thread_3.join();
        // ПРИМЕЧАНИЕ:
        //  к последнему потоку мы присоединяемся, чтобы дать время завершиться фоновым потокам (хотя строго говоря
        //  это не гарантированно).

	//-----------------------------
	/*
	 * Основной проблемой не отсоединенных потоков в том, что очень важно, чтобы между созданием потока
	 * и вызовом join() не произошло исключение, так как join() окажется пропущенным и программа
	 * завершится аварийно.
	 * Эту ситуацию можно разрешить, если вызывать join при обработке исключения и при нормальном исполнении, но проблема
	 * такого подхода в том, что проще допустить ошибку при написании кода.
	 *
	 * Следующий вариант наиболее предпочтителен. Суть его в том, что мы знаем, что деструкторы вызываются
	 * в порядке, обратном созданию объектов в локальном блоке, тогда можно построить объект, в деструкторе
	 * которого вызывается join, который вызывается гарантированно при выходе из блока.
	 *
	 * В каталоге common вы найдете класс thread_guard, который мы используем в следующем вызове.
	 *
	 */
	std::thread my_thread_4 {background_task_as_function};
	thread_guard guard(my_thread_4);

	/*
	 * Теперь не нужно делать вызов join для потока my_thread_4, потому что он будет
	 * в любом случае вызван при завершении функции start.
	 *
	 * Мы можем продолжать делать другие дела в этом потоке ниже.
	 */

	/*
	 * С отсоединенными потоками нельзя связываться прямыми методами коммуникации.
	 * Отсоединенными потоками управляет библиотека реального времени C++ и они
	 * являются подобиями программ демонов в системах *nix
	 */
}

//----------------------------------------------------------------

Application* Tools::app_init() {
	return (Application*) new Lesson_1();
}
