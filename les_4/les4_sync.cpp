
#include "app.h"
#include "examples.h"
#include <iostream>

#include <thread>
 
using namespace Tools;

class Lesson_4 : public Application {
public:
	void start() const;

};

//----------------------------------------------------------------

/*
 * На этом уроке мы рассмотрим механизмы синхронизации. Обычно задач, когда потоки не разделяют данные между собой, не так много.
 * При многопоточном программировании часто возникают проблемы, когда одни потоки читают данные, которые в этот же момент перезаписываются
 * другим потоком. Наверняка такая рассинхронизация приведет к неправильной работе программы.
 *
 * Такая ситуация называется гонкой за данными (data race). Существует два подхода для борьбы с гонками. Первый подход заключается
 * в снабжении разделяемых данных защитным механизмом, который гарантирует, что при нарушении инварианта данных, к ним
 * обращается только один поток. Второй подход заключается в том, что при обращении к одним и тем же данным, работающие
 * с ними потоки не пересекаются во время своей работы (программирование без блокировок, lock-free programming).
 */

/*virtual*/
void Lesson_4::start() const {
	/*
	 * Мы разобьем урок на несколько поучительных примеров, которые показывают простые инструменты синхронизации.
	 */
	Example* examples[] = {new Example_1,	// В этом примере демонстрируется простая синхронизация через мьютекс
                               new Example_2    // В этом примере мы захватываем два мьютекса для реализации одной процедуры
	};

	for (unsigned int i = 0; i < sizeof examples / sizeof *examples; i++) {
		examples[i]->demonstrate();
		delete examples[i];
	}
}

//----------------------------------------------------------------

/*
 * ЭТУ ФУНКЦИЮ РЕКОМЕНДУЕТСЯ НЕ ИЗМЕНЯТЬ (кроме вызова конструктора класса)
 */
Application* Tools::app_init() {
	return (Application*) new Lesson_4();
}
